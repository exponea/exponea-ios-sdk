---
title: Authorization
excerpt: Authorization mode reference for the iOS SDK
slug: ios-sdk-authorization
categorySlug: integrations
parentDocSlug: ios-sdk-setup
---

The SDK exchanges data with the Engagement APIs through authorized HTTP/HTTPS communication. The SDK supports two authorization modes: the default **token authorization** for public API access and the more secure **customer token authorization** for private API access. Developers can choose the appropriate authorization mode for the required level of security.

## Token authorization

The default token authorization mode provides [public API access](https://documentation.bloomreach.com/engagement/reference/authentication#public-api-access) using an API key as a token. 

Token authorization is used for the following API endpoints by default:

* `POST /track/v2/projects/<projectToken>/customers` for tracking of customer data
* `POST /track/v2/projects/<projectToken>/customers/events` for tracking of event data
* `POST /track/v2/projects/<projectToken>/campaigns/clicks` for tracking campaign events
* `POST /data/v2/projects/<projectToken>/customers/attributes` for fetching customer attributes
* `POST /data/v2/projects/<projectToken>/consent/categories` for fetching consents
* `POST /webxp/s/<projectToken>/inappmessages?v=1` for fetching InApp messages
* `POST /webxp/projects/<projectToken>/appinbox/fetch` for fetching of AppInbox data
* `POST /webxp/projects/<projectToken>/appinbox/markasread` for marking of AppInbox message as read
* `POST /campaigns/send-self-check-notification?project_id=<projectToken>` for part of self-check push notification flow

Developers must set the token using the `authorization` [configuration](https://documentation.bloomreach.com/engagement/docs/ios-sdk-configuration) parameter when [initializing the SDK](https://documentation.bloomreach.com/engagement/docs/ios-sdk-setup#initialize-the-sdk):

```swift
Exponea.shared.configure(
    projectToken: "YOUR PROJECT TOKEN",
    authorization: .token("YOUR API KEY")
)
```

## Customer token authorization

Customer token authorization is optional and provides [private API access](https://documentation.bloomreach.com/engagement/reference/authentication#private-api-access) to select Engagement API endpoints. The [customer token](https://documentation.bloomreach.com/engagement/docs/customer-token) contains encoded customer IDs and a signature. When the Bloomreach Engagement API receives a customer token, it first verifies the signature and only processes the request if the signature is valid.

The customer token is encoded using **JSON Web Token (JWT)**, an open industry standard [RFC 7519](https://tools.ietf.org/html/rfc7519) that defines a compact and self-contained way for securely transmitting information between parties.

The SDK sends the customer token in `Bearer <value>` format. Currently, the SDK supports customer token authorization for the following Engagement API endpoints:

* `POST /webxp/projects/<projectToken>/appinbox/fetch` for fetching of AppInbox data
* `POST /webxp/projects/<projectToken>/appinbox/markasread` for marking of AppInbox message as read

Developers can enable customer token authorization by setting the `advancedAuthEnabled` [configuration](https://documentation.bloomreach.com/engagement/docs/ios-sdk-configuration) parameter to `true` when [initializing the SDK](https://documentation.bloomreach.com/engagement/docs/ios-sdk-setup#initialize-the-sdk):

```swift
Exponea.shared.configure(
    projectToken: "YOUR PROJECT TOKEN",
    authorization: .token("YOUR API KEY"),
    advancedAuthEnabled: true
)
```

Additionally, developers must implement the `AuthorizationProviderType` protocol (with `@objc` attribute), ensuring that the `getAuthorizationToken` method returns a valid JWT token that encodes the relevant customer ID(s) and private API key ID:

```swift
@objc(ExponeaAuthProvider)
public class ExampleAuthProvider: NSObject, AuthorizationProviderType {
    required public override init() { }
    public func getAuthorizationToken() -> String? {
        "YOUR JWT TOKEN"
    }
}
```

> ❗️
>
> Customer tokens must be generated by a party that can securely verify the customer's identity. Usually, this means that customer tokens should be generated during the application backend login procedure. When the customer identity is verified (using password, 3rd party authentication, Single Sign-On, etc.), the application backend should generate the customer token and send it to the device running the SDK.

> 📘
>
> Refer to [Generating customer token](https://documentation.bloomreach.com/engagement/docs/customer-token#generating-customer-token) in the customer token documentation for step-by-step instructions to generate a JWT customer token.

### Troubleshooting

If you define `ExponeaAuthProvider` but it is not working as expected, check the logs for the following:
1. If you enable customer token authorization by setting the configuration flag `advancedAuthEnabled` to `true` but the SDK can't find a provider implementation, it will log the following message:
`Advanced authorization flag has been enabled without provider`
2. The registered class musty extend `NSObject`. If it doesn't, you'll see the following log message:
`Class ExponeaAuthProvider does not conform to NSObject`
2. The registered class must conform to `AuthorizationProviderType`. If it doesn't, you'll see the following log message:
`Class ExponeaAuthProvider does not conform to AuthorizationProviderType`

### Asynchronous implementation of AuthorizationProvider

The customer token value is requested for every HTTP call at runtime. The method `getAuthorizationToken()` is written for synchronous usage but is invoked in a background thread. Therefore, you are able to block any asynchronous token retrieval (i.e. other HTTP call) and wait for the result by blocking this thread. If the token retrieval fails, you may return a NULL value but the request will automatically fail.

```swift
@objc(ExponeaAuthProvider)
public class ExampleAuthProvider: NSObject, AuthorizationProviderType {
    required public override init() { }
    public func getAuthorizationToken() -> String? {
        let semaphore = DispatchSemaphore(value: 0)
        var token: String?
        let task = yourAuthTokenReqUrl.dataTask(with: request) {
            token = $0
            semaphore.signal()
        }
        task.resume()
        semaphore.wait()
        return token
    }
}
```

> 👍
>
> Different network libraries support different approaches but the principle stays same - feel free to block the invocation of the `getAuthorizationToken` method.

### Customer token retrieval policy

The customer token value is requested for every HTTP call that requires it.

Typically, JWT tokens have their own expiration lifetime and can be used multiple times. The SDK does not store the token in any cache. Developers may implement their own token cache as they see fit. For example:

```swift
@objc(ExponeaAuthProvider)
public class ExampleAuthProvider: NSObject, AuthorizationProviderType {
    required public override init() { }

    private var tokenCache: String?
    private var lifetime: Double?

    public func getAuthorizationToken() -> String? {
        if tokenCache == nil || hasExpired(lifetime) {
            (tokenCache, lifetime) = loadJwtToken()
        }
        return tokenCache
    }

    private func loadJwtToken() -> String? {
        ...
    }
}
```

> ❗️
>
> Please consider to store your cached token more securely. iOS offers multiple options such as [Keychain](https://developer.apple.com/documentation/security/certificate_key_and_trust_services/keys/storing_keys_in_the_keychain) or [CryptoKit](https://developer.apple.com/documentation/cryptokit/).

> ❗️
>
> A customer token is valid until its expiration and is assigned to the current customer IDs. Bear in mind that if customer IDs change (due to invoking the `identifyCustomer` or `anonymize` methods), the customer token may become invalid for future HTTP requests invoked for new customer IDs.